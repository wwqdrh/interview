- 前缀和
  - 区域和检索、数组不可变
  - 二维区域和检索、矩阵不可变
- 差分数组
  - 区间加法
- 双指针
  - n个有序链表合并
  - 链表拆分
  - 单链表的第k个节点(中点或者倒数第几个点)
  - 找出单链表的环
  - 找出两个单链表的交点
  - 原地修改数组，有序数组(链表)去重
  - 最长回文子串，（从中心向两边扩散的双指针）
  - 数组反转
- 滑动窗口
  - 最小覆盖子串
  - 字符串排列，判断s2是否包含s1排列
  - 找所有字母异位词
  - 最长无重复子串
- 二分搜索
  - 寻找中间的一个数
  - 寻找左侧边界
  - 寻找右侧边界
- 递归
  - 反转链表
    - 全部反转
    - 反转前n个
    - k个一组反转

---

- 前缀和技巧适用于快速、频繁地计算一个原始数组不会被修改的索引区间内的元素之和
- 差分数组适用频繁对原始数组的某个区间元素进行增减
- 处理链表的时候，可以创建一个虚拟头节点简化边界条件处理
- 数组问题中比较常见的快速指针技巧是让你原地修改数组（去重或者删除某些元素）
- 判断字符串中的最长回文子串是适用从中心向两端扩散的双指针技巧
- 滑动窗口思路模版：1、什么时候移动右边界扩大窗口，需要更新哪些数据。2、什么时候暂停扩大窗口并移动左边界缩小窗口，需要更新哪些数据。3、要的结果是在扩大窗口还是缩小窗口更新
- 二分查找
  - 基本：初始化(right = nums.length - 1, `[left, right]`), 条件(left <= right, left = mid + 1, right = mid - 1), 找到target可以立即返回
  - 寻找左边界：初始化(right = nums.length, `[left, right)`), 条件(left < right, left = mid + 1, right = mid), 找到target不要立即返回，收紧右侧边界以锁定左侧边界
  - 寻找右边界：初始化(right = nums.length, `[left, right)`), 条件(left < right, left = mid + 1, right = mid), 找到target不要立即返回，收紧左侧边界以锁定右侧边界，最后将结果减一
- 田忌赛马的策略：两边排序后，一一比较能赢就赢(没必要节约)，不能赢就用最弱的去比
- 递归算法，最重要的是定义好递归函数的的定义
- 处理环形数据常用套路就是将数组长度翻倍(只需要使用下标实现逻辑翻倍)
- 单调队列结构: 既能够维护队列元素先进先出时间顺序，有能够正确维护队列中所有元素的最值
- lru缓存实现的底层数据结构是哈希表+链表
- lfu缓存实现的底层数据结构是频率哈希表+数据哈希表
- 每个元素随机概率相同，底层数据结构必须是数组，如果要o1删除和添加就还需要一个值域索引的哈希表，删除的时候将要删除的转移到后面
- 求数据流的中位数，可以使用两个优先队列，分别存储左边与右边部分的元素
- BFS、DFS、回溯算法、动态规划、分治算法、图论算法都是二叉树算法的衍生
- 二叉树解题思维模式
  - 是否可以通过遍历一遍二叉树得到答案
  - 是否可以定义一个递归函数，通过子问题的答案推到出原问题的答案
  - 如果单独抽出一个二叉树节点，它需要做什么事情，需要在什么时候做
- 快速排序相当于二叉树的前序遍历（自顶向下），归并排序相当于二叉树的后序遍历（自底向上）
- 前序遍历只能从函数参数中获取父节点传递来的数据，而后续位置的代码不仅可以获取参数数据，还可以获取子树通过函数返回回来的数据
- 动归/DFS/回溯算法都可以看做二叉树问题的扩展
  - 动归属于分解问题，关注点在于整棵子树
  - 回溯属于遍历，关注点在于节点间的树枝（节点之间的移动），（回溯算法将做选择、撤销选择的逻辑放在for循环里面）
  - DFS属于遍历，关注点在于单个节点（DFS算法把做选择、撤销选择放在for循环外面）
- 二叉树的层序遍历框架，常用于求无权图的最短路径问题
- dijkstra算法常用于求加权图的最短路径问题
- 二叉搜索树转链表的思路，定义一个拉平语义的递归函数，将右子树连接到左子树下方，然后将左子树作为右子树
- 二叉树的构造问题一般都是使用分解问题的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树
- 通过前序+中序 或者 后序+中序 遍历结果能够构造二叉树
- 二叉树的序列化和反序列化如果包含了空指针，只有一个遍历顺序（前序或者后序）那么也可以还原出二叉树
- 判断二叉搜索树是否合法的时候，需要增加额外参数，将当前比较中的能够确定的最大和最小节点带上,`isValidBST(TreeNode root, TreeNode min, TreeNode maxs)`
- 在BST中删除一个数分三种情况
  - 恰好是末端节点，直接删除
  - 还有一个非空子节点，让它来接替自己的位置
  - 有两个非空子节点，需要在左子树中找到最大的那个或者右子树中最小的那个来接替自己（获取右子树最小的节点、删除右子树最小的节点、右子树最小节点接替当前节点，设置left、right）
- 避免递归中嵌套递归，可以优化代码，使用后序遍历多返回几个返回值，在一次递归中就将要计算的值计算出来
- 图本质上就是一个高级点的多叉树，适用于树的DFS/BFS遍历算法，全部适用于图
- 图的数据结构表达一般是使用邻接表或者领接矩阵(二维布尔数组)来实现，邻接表占用空间更少，但是无法快速判断两个节点是否相邻
- 在无向图中，度就是每个节点相连的边的条数。在有向图每个节点被细分为入度和出度
- 有向加权图，其实就是邻接矩阵中的值，0表示没有连接，其他值表示权重
- 无向图，就是邻接矩阵中`data[i][j]`以及`data[j][i]`都是true
- 图的遍历相较于多叉树的不同点在于，图可能是有环的，所以需要一个visited数组进行辅助判断不要回到自身
- 环检测：
  - DFS思路：对于依赖问题，首先想到的就是将问题转化成有向图数据结构，只要图中存在环，那就说明存在循环依赖。
  - BFS思路：构建邻接表，计算每个节点的入度，BFS遍历从入度为0的开始(相当于多叉树根节点)，遍历过程中弹出节点，并且更新邻接点的入度将入度变为0的加入队列。如果最终所有节点遍历过(count等于节点数，因为如果存在环那么它的入度不会为0，无法遍历到)则说明不存在环
- 拓扑排序：只有有向无环图（其实就相当于多叉树了）才可以拓扑排序
  - DFS思路：将后序遍历结果进行反转就是拓扑排序的结果
  - BFS思路：BFS环检测时的节点遍历顺序就是拓扑排序结果
- 二分图定义：可以通俗的理解成有一副图，需要使用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同。一个应用场景就是，电影和演员之间的多对多关系，最直观的是使用两个哈希表分别建立索引数据，但是如果使用二分图就可以直接将电影与演员连接起来，避免重复存储
- 二分图判定，遍历一遍图（通常使用DFS，更加直观），一边遍历一边染色，看能不能用两种颜色给所有节点染色，并且相邻节点的颜色都不相同
- 并查集：根据动态连通性的性质（自反性、对称性、传递性），如果某两个节点被连通，则让其中的任意一个节点的根节点连接到另一个节点的根节点上，也就是说，如果节点p和q连通的话，他们一定拥有相同的根节点。
  - 这里面有一个坑，就是寻找根节点可能会退化成O(n), 所以需要进行平衡，额外使用一个size数组记录每棵树的节点树，避免头重脚轻，将find函数复杂度下降为O(logN)
  - 更近一步，我们不在乎每棵树的结构只在乎根节点，可以近一步压缩高度，使其保持为常数`parent[x] = parent[parent[x]]`或者递归压缩形式`parent[x] = find(parent[x])`, (第二种更好，压缩更彻底)
- 并查集主要思路就是适时增加虚拟节点，想办法让元素分门别类，建立动态连通关系
- 最小生成树算法(针对无向加权图)：生成树是在图中找到一棵包含图中所有节点的树（包含所有顶点的无环连通子图），那么最小生成树就是在所有生成树中权重和最小的那棵生成树。
  - prim：使用BFS+visited数组避免成环，不需要事先排序，而是使用优先级队列动态实现排序的效果。核心思想是每次切分都能找到最小生成树的一条边，然后进行新一轮切分，直到找到最小生成树的所有边
  - kruskal：针对边，贪心思想+并查集算法，先对权重排序，从权重最小的开始，选择合适的边加入mst集合，并查集用来保证挑选出来的边一定是组成一棵树，而不会是环
- dijkstra最短路径算法，带dp table的bfs算法。计算最短路径的正确性依赖一个前提，路径中每增加一条边，路径的总权重就会增加